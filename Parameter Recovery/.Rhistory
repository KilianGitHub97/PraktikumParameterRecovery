par = coef(fitted_model),
true_par = model$get_par("all"),
convergence = fitted_model$fitobj$convergence
)
}
}
}
}
}
results
class(results)
# Parameter Recovery
results <-
foreach(discount = discounts, .combine = "rbind", .packages = c("cognitivemodels", "data.table")) %:%
foreach (nblock = nblocks, .combine = "rbind") %:%
foreach (type = types, .combine = "rbind") %:%
foreach (row = 1:nrow(true_pars), .combine = "rbind") %:%
foreach(run = runs, .combine = "rbind") %dopar%
{
{
{
{
# make true_par a single row of the expand.grid()
true_par <- true_pars[row, ]
# replicate all rows of data_shep by the number of nblock
data <- data_shep[rep(1:nrow(data_shep), nblock),]
# GCM with fixed parameters
model <- gcm(data = data,
formula = ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
fix = true_par,
discount = 0)
# Simulation of repeated measurements
predictions <- predict(model)
{
# Add the predicted binominal value ({0,1}) to the data
data$simulations <- rbinom(length(predictions) , 1, predictions)
# Estimate the parameters given the response (simulations) and the class (cat_)
fitted_model <- gcm(data = data,
formula = simulations ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
discount = discount)
# Save the necessary components to the results
data.frame(
run = run,
discount = discount,
nblock = nblock,
type = type,
row = row,
names = names(coef(fitted_model)),
par = coef(fitted_model),
true_par = model$get_par("all"),
convergence = fitted_model$fitobj$convergence
)
}
}
}
}
}
class(results)
results
# Parameter Recovery
results <-
foreach(discount = discounts, .combine = "rbind", .packages = c("cognitivemodels", "data.table")) %:%
foreach (nblock = nblocks, .combine = "rbind") %:%
foreach (type = types, .combine = "rbind") %:%
foreach (row = 1:nrow(true_pars), .combine = "rbind") %:%
foreach(run = runs, .combine = "rbind") %dopar%
{
{
{
{
# make true_par a single row of the expand.grid()
true_par <- true_pars[row, ]
# replicate all rows of data_shep by the number of nblock
data <- data_shep[rep(1:nrow(data_shep), nblock),]
# GCM with fixed parameters
model <- gcm(data = data,
formula = ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
fix = true_par,
discount = 0)
# Simulation of repeated measurements
predictions <- predict(model)
{
# Add the predicted binominal value ({0,1}) to the data
data$simulations <- rbinom(length(predictions) , 1, predictions)
# Estimate the parameters given the response (simulations) and the class (cat_)
fitted_model <- gcm(data = data,
formula = simulations ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
discount = discount)
# Save the necessary components to the results
data.table(
run = run,
discount = discount,
nblock = nblock,
type = type,
row = row,
names = names(coef(fitted_model)),
par = coef(fitted_model),
true_par = model$get_par("all"),
convergence = fitted_model$fitobj$convergence
)
}
}
}
}
}
results
glimpse(results)
system.time(
# Parameter Recovery
results <-
foreach(discount = discounts, .combine = "rbind", .packages = c("cognitivemodels", "data.table")) %:%
foreach (nblock = nblocks, .combine = "rbind") %:%
foreach (type = types, .combine = "rbind") %:%
foreach (row = 1:nrow(true_pars), .combine = "rbind") %:%
foreach(run = runs, .combine = "rbind") %dopar%
{
{
{
{
# make true_par a single row of the expand.grid()
true_par <- true_pars[row, ]
# replicate all rows of data_shep by the number of nblock
data <- data_shep[rep(1:nrow(data_shep), nblock),]
# GCM with fixed parameters
model <- gcm(data = data,
formula = ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
fix = true_par,
discount = 0)
# Simulation of repeated measurements
predictions <- predict(model)
{
# Add the predicted binominal value ({0,1}) to the data
data$simulations <- rbinom(length(predictions) , 1, predictions)
# Estimate the parameters given the response (simulations) and the class (cat_)
fitted_model <- gcm(data = data,
formula = simulations ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
discount = discount)
# Save the necessary components to the results
data.table(
run = run,
discount = discount,
nblock = nblock,
type = type,
row = row,
names = names(coef(fitted_model)),
par = coef(fitted_model),
true_par = model$get_par("all"),
convergence = fitted_model$fitobj$convergence
)
}
}
}
}
}
)
system.time(
# Parameter Recovery
results <-
foreach(discount = discounts, .combine = "rbind", .packages = c("cognitivemodels", "data.table")) %:%
foreach (nblock = nblocks, .combine = "rbind") %:%
foreach (type = types, .combine = "rbind") %:%
foreach (row = 1:nrow(true_pars), .combine = "rbind") %:%
foreach(run = runs, .combine = "rbind") %dopar%
{
{
{
{
# make true_par a single row of the expand.grid()
true_par <- true_pars[row, ]
# replicate all rows of data_shep by the number of nblock
data <- data_shep[rep(1:nrow(data_shep), nblock),]
# GCM with fixed parameters
model <- gcm(data = data,
formula = ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
fix = true_par,
discount = 0)
# Simulation of repeated measurements
predictions <- predict(model)
{
# Add the predicted binominal value ({0,1}) to the data
data$simulations <- rbinom(length(predictions) , 1, predictions)
# Estimate the parameters given the response (simulations) and the class (cat_)
fitted_model <- gcm(data = data,
formula = simulations ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
discount = discount)
# Save the necessary components to the results
data.table(
run = run,
discount = discount,
nblock = nblock,
type = type,
row = row,
names = names(coef(fitted_model)),
par = coef(fitted_model),
true_par = model$get_par("all"),
convergence = fitted_model$fitobj$convergence
)
}
}
}
}
}
)
system.time(
# Parameter Recovery
results <-
foreach(discount = discounts, .combine = "rbind", .packages = c("cognitivemodels", "data.table")) %:%
foreach (nblock = nblocks, .combine = "rbind") %:%
foreach (type = types, .combine = "rbind") %:%
foreach (row = 1:nrow(true_pars), .combine = "rbind") %:%
foreach(run = runs, .combine = "rbind") %dopar%
{
{
{
{
# make true_par a single row of the expand.grid()
true_par <- true_pars[row, ]
# replicate all rows of data_shep by the number of nblock
data <- data_shep[rep(1:nrow(data_shep), nblock),]
# GCM with fixed parameters
model <- gcm(data = data,
formula = ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
fix = true_par,
discount = 0)
# Simulation of repeated measurements
predictions <- predict(model)
{
# Add the predicted binominal value ({0,1}) to the data
data$simulations <- rbinom(length(predictions) , 1, predictions)
# Estimate the parameters given the response (simulations) and the class (cat_)
fitted_model <- gcm(data = data,
formula = simulations ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
discount = discount)
# Save the necessary components to the results
data.table(
run = run,
discount = discount,
nblock = nblock,
type = type,
row = row,
names = names(coef(fitted_model)),
par = coef(fitted_model),
true_par = model$get_par("all"),
convergence = fitted_model$fitobj$convergence
)
}
}
}
}
}
)
system.time(
# Parameter Recovery
results <-
foreach(discount = discounts, .combine = "rbind", .packages = c("cognitivemodels", "data.table")) %:%
foreach (nblock = nblocks, .combine = "rbind") %:%
foreach (type = types, .combine = "rbind") %:%
foreach (row = 1:nrow(true_pars), .combine = "rbind") %:%
foreach(run = runs, .combine = "rbind") %dopar%
{
{
{
{
# make true_par a single row of the expand.grid()
true_par <- true_pars[row, ]
# replicate all rows of data_shep by the number of nblock
data <- data_shep[rep(1:nrow(data_shep), nblock),]
# GCM with fixed parameters
model <- gcm(data = data,
formula = ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
fix = true_par,
discount = 0)
# Simulation of repeated measurements
predictions <- predict(model)
{
# Add the predicted binominal value ({0,1}) to the data
data$simulations <- rbinom(length(predictions) , 1, predictions)
# Estimate the parameters given the response (simulations) and the class (cat_)
fitted_model <- gcm(data = data,
formula = simulations ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
discount = discount)
# Save the necessary components to the results
data.table(
run = run,
discount = discount,
nblock = nblock,
type = type,
row = row,
names = names(coef(fitted_model)),
par = coef(fitted_model),
true_par = model$get_par("all"),
convergence = fitted_model$fitobj$convergence
)
}
}
}
}
}
)
system.time(
# Parameter Recovery
results <-
foreach(discount = discounts, .combine = "rbind", .packages = c("cognitivemodels", "data.table")) %:%
foreach (nblock = nblocks, .combine = "rbind") %:%
foreach (type = types, .combine = "rbind") %:%
foreach (row = 1:nrow(true_pars), .combine = "rbind") %:%
foreach(run = runs, .combine = "rbind") %dopar%
{
{
{
{
# make true_par a single row of the expand.grid()
true_par <- true_pars[row, ]
# replicate all rows of data_shep by the number of nblock
data <- data_shep[rep(1:nrow(data_shep), nblock),]
# GCM with fixed parameters
model <- gcm(data = data,
formula = ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
fix = true_par,
discount = 0)
# Simulation of repeated measurements
predictions <- predict(model)
{
# Add the predicted binominal value ({0,1}) to the data
data$simulations <- rbinom(length(predictions) , 1, predictions)
# Estimate the parameters given the response (simulations) and the class (cat_)
fitted_model <- gcm(data = data,
formula = simulations ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
discount = discount)
# Save the necessary components to the results
data.table(
run = run,
discount = discount,
nblock = nblock,
type = type,
row = row,
names = names(coef(fitted_model)),
par = coef(fitted_model),
true_par = model$get_par("all"),
convergence = fitted_model$fitobj$convergence
)
}
}
}
}
}
)
library(data.table)
library(tidyverse)
library(cognitivemodels)
library(doParallel)
library(foreach)
library(plotly)
# Setup -------------------------------------------------------------------
discounts <- 1:2 #0:8
nblocks <- 2 #später 1:6
types <- 1 #1:6
true_pars <- expand.grid(lambda = 1:2,
size = c(0.2, 0.5, 0.8),
shape = c(0.2, 0.5, 0.8),
r = 1,
q = 1,
b0 = 0.5,
tau = c(0.1, 1, 2)) #more sensitive
true_pars <- true_pars[1,] #delete
runs <- 1:5 #1:50
data_raw_shepard <- data.frame(
size = as.factor( c("small", "small", "small", "small", "large", "large", "large", "large" )), # c(small, large)
shape = as.factor( c("triangle", "triangle", "square", "square", "triangle", "triangle", "square", "square" )), # c(triangle, square)
color = as.factor( c("black", "white", "black", "white", "black", "white", "black", "white")), # c(black, white)
cat_1 = c(0, 1, 0, 1, 0, 1, 0, 1), # c(0, 1)
cat_2 = c(0, 1, 1, 0, 0, 1, 1, 0), # c(0, 1)
cat_3 = c(0, 0, 1, 1, 0, 1, 0, 1), # c(0, 1)
cat_4 = c(0, 1, 1, 1, 0, 0, 0, 1), # c(0, 1)
cat_5 = c(0, 1, 1, 0, 0, 1, 0, 1), # c(0, 1)
cat_6 = c(1, 0, 0, 1, 0, 1, 1, 0) # c(0, 1)
)
data_shep <- data_raw_shepard %>%
mutate( size = recode(size, "small" = 0, "large" = 1),
shape = recode(shape, "triangle" = 0, "square" = 1),
color = recode(color, "black" = 0, "white" = 1))
# Simulate ----------------------------------------------------------------
registerDoParallel(4)
# Parameter Recovery
results <-
foreach(discount = discounts, .combine = "rbind", .packages = c("cognitivemodels", "data.table")) %:%
foreach (nblock = nblocks, .combine = "rbind") %:%
foreach (type = types, .combine = "rbind") %:%
foreach (row = 1:nrow(true_pars), .combine = "rbind") %:%
foreach(run = runs, .combine = "rbind") %dopar%
{
{
{
{
# make true_par a single row of the expand.grid()
true_par <- true_pars[row, ]
# replicate all rows of data_shep by the number of nblock
data <- data_shep[rep(1:nrow(data_shep), nblock),]
# GCM with fixed parameters
model <- gcm(data = data,
formula = ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
fix = true_par,
discount = 0)
# Simulation of repeated measurements
predictions <- predict(model)
{
# Add the predicted binominal value ({0,1}) to the data
data$simulations <- rbinom(length(predictions) , 1, predictions)
# Estimate the parameters given the response (simulations) and the class (cat_)
fitted_model <- gcm(data = data,
formula = simulations ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
discount = discount)
# Save the necessary components to the results
data.table(
run = run,
discount = discount,
nblock = nblock,
type = type,
row = row,
names = names(coef(fitted_model)),
par = coef(fitted_model),
true_par = model$get_par("all"),
convergence = fitted_model$fitobj$convergence
)
}
}
}
}
}
# Parameter Recovery
results <-
foreach(discount = discounts, .combine = "rbind", .packages = c("cognitivemodels", "data.table")) %:%
foreach (nblock = nblocks, .combine = "rbind") %:%
foreach (type = types, .combine = "rbind") %:%
foreach (row = 1:nrow(true_pars), .combine = "rbind") %:%
foreach(run = runs, .combine = "rbind") %dopar%
{
{
{
{
# make true_par a single row of the expand.grid()
true_par <- true_pars[row, ]
# replicate all rows of data_shep by the number of nblock
data <- data_shep[rep(1:nrow(data_shep), nblock),]
# GCM with fixed parameters
model <- gcm(data = data,
formula = ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
fix = true_par,
discount = 0)
# Simulation of repeated measurements
predictions <- predict(model)
{
# Add the predicted binominal value ({0,1}) to the data
data$simulations <- rbinom(length(predictions) , 1, predictions)
# Estimate the parameters given the response (simulations) and the class (cat_)
fitted_model <- gcm(data = data,
formula = simulations ~ size + shape + color,
class = paste("cat", type, sep = "_"),
choicerule = "softmax",
discount = discount)
# Save the necessary components to the results
data.table(
run = run,
discount = discount,
nblock = nblock,
type = type,
row = row,
names = names(coef(fitted_model)),
par = coef(fitted_model),
true_par = model$get_par("all"),
convergence = fitted_model$fitobj$convergence
)
}
}
}
}
}
View(results)
